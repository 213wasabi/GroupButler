local config = require "groupbutler.config"
local api = require "telegram-bot-api.methods".init(config.telegram.token)
local locale = require "groupbutler.languages"
local i18n = locale.translate
local null = require "groupbutler.null"

local _M = {}

function _M:new(update_obj)
	local plugin_obj = {}
	setmetatable(plugin_obj, {__index = self})
	for k, v in pairs(update_obj) do
		plugin_obj[k] = v
	end
	return plugin_obj
end

local function get_reply_markup(self, msg, text)
	local u = self.u
	local reply_markup, new_text = u:reply_markup_from_text(text)
	return reply_markup, new_text:replaceholders(msg, "rules", "title")
end

local function new_pin(self, msg, pin_text)
	local u = self.u
	local db = self.db

	local reply_markup, text = get_reply_markup(self, msg, pin_text)
	local ok, err = api.send_message{
		chat_id = msg.chat.id,
		text = text,
		parse_mode = "Markdown",
		disable_web_page_preview = true,
		reply_markup = reply_markup
	}
	if not ok then
		msg:send_reply(u:get_sm_error_string(err), "Markdown")
		return
	end

	local pin_key = "chat:"..msg.chat.id..":pin"
	local pin_id = ok.message_id
	db:set(pin_key, pin_id)
	api.pin_chat_message(msg.chat.id, pin_id, u:is_silentmode_on(msg.chat.id))
	return
end

function _M:onTextMessage(blocks)
	local msg = self.message
	local u = self.u
	local db = self.db

	if msg.chat.type == "private"
	or not msg:is_from_admin() then
		return
	end

	local pin_key = "chat:"..msg.chat.id..":pin"
	local pin_text = blocks[2]
	if msg.reply_to_message and msg.reply_to_message.text then
		pin_text = msg.reply_to_message.text
	end

	if not pin_text then
		local pin_id = db:get(pin_key)
		if pin_id == null then
			msg:send_reply(i18n("I couldn't find any message generated by <code>/pin</code>"), "html")
			return
		end
		local ok, err = api.send_message{
			chat_id = msg.chat.id,
			text = i18n("Last message generated by <code>/pin</code> ^"),
			parse_mode = "html",
			reply_to_message_id = pin_id,
		}
		if not ok and err.description:lower():match("reply message not found") then
			msg:send_reply(i18n("The old message generated with <code>/pin</code> does not exist anymore."), "html")
			db:del(pin_key)
			return
		end
		return
	end

	local pin_id = db:get(pin_key)
	if pin_id == null
	or blocks[1] == "newpin" then
		new_pin(self, msg, pin_text)
		return
	end

	local reply_markup, text = get_reply_markup(self, msg, pin_text)
	local ok, err = api.edit_message_text{
		chat_id = msg.chat.id,
		message_id = pin_id,
		text = text,
		parse_mode = "Markdown",
		disable_web_page_preview = true,
		reply_markup = reply_markup
	}

	if not ok then
		if err.description:lower():match("message to edit not found") then
			new_pin(self, msg, pin_text)
			return
		end
		msg:send_reply(u:get_sm_error_string(err), "Markdown")
		return
	end
	pin_id = ok.message_id
	db:set(pin_key, pin_id)
	api.pin_chat_message(msg.chat.id, pin_id, u:is_silentmode_on(msg.chat.id))
	return
end

_M.triggers = {
	onTextMessage = {
		config.cmd..'(pin)$',
		config.cmd..'(pin) (.*)$',
		config.cmd..'(newpin) (.*)$'
	}
}

return _M
